#include <GameLight/GameLight.h>
int GameLight::TotalLights=0;
/*************************************************
LIGHTS SOURCES USED IN 3D ENVIRONMENT ARE GENERALY OF 3 TYPES
1) DIRECTIONAL LIGHTS
2) POINTS LIGHTS
3) SPOTLIGHTS

//************
SHADING MODELS
//************
1) FLAT SHADING - WE USE ONE NORMAL FOR THE ENTIRE POLYGON / TRIANGLE AND THAT ONE NORMAL IS USED
                  FOR ALL LIGHT CALCULATIONS FOR ALL FRAGMENTS / PIXELS INSIDE THAT POLYGON SO WE END UP
                  WITH ONE COLOR FOR THE ENTIRE POLYGON

2) GOURAUD SHADING - EACH VERTEX OF THE POLYGON HAS A NORMAL ASSIGNED TO IT WHICH IS USED TO CALCULATE THE
                     COLOR FOR EACH OF THOSE VERICES AND THOSE COLORS ARE INTERPOLATED TO PRODUCE
                     THE COLOR FOR EACH FRAGMENT THAT IS INSIDE THE POLYGON.

3) PHONG SHADING - EACH VERTEX OF THE POLYGON HAS A NORMAL ASSIGNED TO IT. EACH OF THESE NORMALS ARE THEN
                   INTERPOLATED TO PRODUCE THE NORMAL OF EACH FRAGMENT OF THE POLYGON WHICH IS THEN USED TO
                   PRODUCE THE COLOR AND SPECULAR HIGHLIGHS FOR EACH OF THE FRAGMENT OF THE POLYGON


INTERPOLATION IS THE PROCESS OF ESTIMATING UNKNOWN VALUES THAT FALL BETWEEN KNOWN VALUES OR
INTERPOLATION IS A TYPE OF ESTIMATION, A METHOD OF CONSTRUCTING NEW DATA POINTS WITHIN THE RANGE OF A DISCRETE SET OF KNOWN DATA POINTS

//********************************************************
AMBIENT, DIFFUSE AND SPECULAR COMPONENTS OF A LIGHT SOURCE
//********************************************************
1) AMBIENT COLOR
    EVEN WHEN IT IS DARK THERE IS USUALLY STILL SOME LIGHT SOMEWHERE IN THE WORLD (THE MOON, A DISTANT LIGHT)
    SO OBJECTS ARE ALMOST NEVER COMPLETELY DARK. TO SIMULATE THIS WE USE AN AMBIENT LIGHTING CONSTANT THAT
    ALWAYS GIVES THE OBJECT SOME COLOR

    AMBIENT COLOR IS CALCULATED USING THE FOLLOWING FORMULAE:
    AMBIENT COLOR=(LIGHT COLOR * AMBIENT CONSTANT OF THE OBJECT) * COLOR OF THE OBJECT

2) DIFFUSE COLOR
    SIMULATES THE DIRECTIONAL IMPACT A LIGHT OBJECT HAS ON AN OBJECT. THIS IS THE MOST VISUALLY SIGNIFICANT
    COMPONENT OF THE LIGHTING MODEL. THE MORE A PART OF AN OBJECT FACES THE LIGHT SOURCE, THE BRIGHTER IT BECOMES

    DIFFUSE COLOR IS CALCULATED USING THE FOLLOWING FORMULAE:
    DIFFUSE COLOR=(LIGHT COLOR * DOTPRODUCT(NORMAL OF THE OBJECT, DIRECTION VECTOR FROM OBJECT TO LIGHT SOURCE)) * COLOR OF THE OBJECT

    IF THE NORMAL OF THE OBJECT IS ALIGNED WITH THE LIGHT DIRECTION THEN THEIR DOT PRODUCT WILL BE 1
    LEADING TO MAXIMUM COLOR STRENGTH FOR THE OBJECT

3) SPECULAR COLOR
    SIMULATES THE BRIGHT SPOT OF A LIGHT THAT APPEARS ON SHINY OBJECTS. SPECULAR HIGHLIGHTS ARE OFTEN MORE INCLINED
    TO THE COLOR OF THE LIGHT THAN THE COLOR OF THE OBJECT.

    SPECULAR COLOR IS CALCULATED BY THE FOLLOWING METHOD:
    A) CALCULATE THE VIEWER DIRECTION I.E THE DIRECTION FROM THE OBJECT TO THE CAMERA
    B) CALCULATE THE REFLECTION DIRECTION WHICH IS THE OPPOSITE / NEGATIVE OF THE DIRECTION FROM THE OBJECT TO THE LIGHT SOURCE
    C) CALCULATE THE DOT PRODUCT BETWEEN THE VIEWER DIRECTION AND REFLECTION DIRECTION
    D) RAISE THE DOT PRODUCT TO THE POWER OF A SHININESS CONSTANT SET FOR THE OBJECT
    E) SET THE CONSTANT "SPECULARSTRENGTH" FOR THE OBJECT SO THE COLOR OF THE SPECULAR HIGHLIGHT IS NOT TOO DOMINATING
    E) USE THE FINAL VALUE FOR SPECULAR COLOR CALCULATION

    SPECULAR COLOR=(LIGHT COLOR * POWER(DOTPRODUCT(VIEWER DIRECTION, REFLECTION DIRECTION) ^ SHININESS CONSTANT) * SPECULARSTRENGTH) * OBJECT COLOR

4) THE FINAL COLOR FROM A LIGHT SOURCE CAN BE CALCULATED AS FOLLOWS:
   AMBIENT COLOR=(LIGHT COLOR * AMBIENT CONSTANT OF THE OBJECT)
   DIFFUSE COLOR=(LIGHT COLOR * DOTPRODUCT(NORMAL OF THE OBJECT, DIRECTION VECTOR FROM OBJECT TO LIGHT SOURCE))
   SPECULAR COLOR=(LIGHT COLOR * POWER(DOTPRODUCT(VIEWER DIRECTION, REFLECTION DIRECTION) ^ SHININESS CONSTANT) * SPECULARSTRENGTH)
   FINAL COLOR= (AMBIENT COLOR + DIFFUSE COLOR + SPECULAR COLOR) * COLOR OF THE OBJECT


//******************************
//    DIRECTIONAL LIGHTS
//******************************
DIRECTIONAL LIGHTS ARE BASICALLY LIGHTS SOURCES THAT WAS SO FAR AWAY FROM THE OBJECTS THAT WHEN THE LIGHT RAYS
HIT THE OBJECT THEY ALL SEEM PARALLEL. WHEN A LIGHT SOURCE IS MODELED TO BE INFINITELY FAR AWAY IT IS CALLED A DIRECTIONAL LIGHT SINCE ALL ITS
LIGHT RAYS HAVE THE SAME DIRECTION; IT IS INDEPENDENT OF THE LOCATION OF THE LIGHT SOURCE. AN EXAMPLE OF SUCH A LIGHT SOURCE WOULD BE THE SUN

THE DATA STRUCTURE FOR DIRECTIONAL LIGHTS CONTAINS THE FOLLOWING VARIABLES:
1) COLOR OF THE LIGHT
2) DIRECTION OF THE LIGHT RAYS

//******************************
//    POINT LIGHTS
//******************************
A POINT LIGHT IS A LIGHT SOURCE WITH A GIVEN POSITION SOMEWHERE IN A WORLD THAT ILLUMINATES IN ALL DIRECTIONS
WHERE THE LIGHT RAYS FADE OUT OVER DISTANCE. THINK OF LIGHT BULBS AND TORCHES AS LIGHT CASTERS THAT ACT AS A POINT LIGHT.
TO REDUCE THE INTENSITY OF LIGHT, OVER THE DISTANCE A LIGHT RAY TRAVELS, IS GENERALLY CALLED ATTENUATION.
IN THE REAL WORLD, LIGHTS ARE GENERALLY QUITE BRIGHT STANDING CLOSE BY, BUT THE BRIGHTNESS OF A LIGHT SOURCE DIMINISHES QUICKLY
AT THE START AND THE REMAINING LIGHT INTENSITY MORE SLOWLY DIMINISHES OVER DISTANCE.

THE DATA STRUCTURE FOR POINT LIGHT CONTAINS THE FOLLOWING VARIABLES:
1) COLOR OF THE LIGHT
2) POSITION OF THE LIGHT SOURCE
3) CONSTANT
4) LINEAR CONSTANT
5) QUADRATIC CONSTANT

THE FORMULAE TO CALCULATE ATTENUATION IS
ATTENUATION = 1.0 / (LIGHT.CONSTANT + LIGHT.LINEAR * DISTANCE + LIGHT.QUADRATIC * (DISTANCE * DISTANCE));

DISTANCE IS THE DISTANCE FROM THE FRAGMENT TO THE LIGHT SOURCE.
LIGHT.CONSTANT IS A CONSTANT TO MAKE SURE THE DENOMINATORS NEVER GOES BELOW 1.0 AND IS USUALLY SET AT 1.0
LIGHT.LINEAR IS A LINEAR CONSTANT
LIGHT.QUADRATIC IS A QUADRATIC CONSTANT
THE FUNCTION : GetDistanceValues() HELPS GET THE RIGHT "LIGHT.LINEAR" VALUES AND "LIGHT.QUADRATIC" VALUES BASED ON THE
DISTANCE VALUES THAT YOU WOULD LIKE THE LIGHT TO COVER

THE ATTENUATION CALCULATED ABOVE IS THEN USED IN THE FINAL COLOR CALCULATION AS SHOWN BELOW:
FINAL COLOR=((ATTENUATION * AMBIENT COLOR) + (ATTENUATION * DIFFUSE COLOR) + (ATTENUATION * SPECULAR COLOR)) * COLOR OF THE OBJECT

//******************************
//    SPOT LIGHTS
//******************************
A SPOTLIGHT IS A LIGHT SOURCE THAT IS LOCATED SOMEWHERE IN THE ENVIRONMENT THAT, INSTEAD OF SHOOTING LIGHT RAYS IN ALL DIRECTIONS,
ONLY SHOOTS THEM IN A SPECIFIC DIRECTION. THE RESULT IS THAT ONLY THE OBJECTS WITHIN A CERTAIN RADIUS OF THE SPOTLIGHT’S DIRECTION ARE LIT
AND EVERYTHING ELSE STAYS DARK. A GOOD EXAMPLE OF A SPOTLIGHT WOULD BE A STREET LAMP OR A FLASHLIGHT

THE DIRECTION AND A CUTOFF ANGLE OF THE SPOTLIGHT SPECIFIES THE RADIUS OF THE SPOTLIGHT. FOR EACH OBJECT WE CALCULATE IF THE OBJECT IS
BETWEEN THE SPOTLIGHT’S CUTOFF DIRECTIONS (THUS IN ITS CONE) AND IF SO, WE LIGHT THE OBJECT ACCORDINGLY

THE DATA STRUCTURE FOR SPOT LIGHT CONTAINS THE FOLLOWING VARIABLES:
1) COLOR OF THE LIGHT SOURCE
2) POSITION OF THE LIGHT SOURCE
3) DIRECTION OF THE LIGHT SOURCE
4) CONSTANT
5) LINEAR CONSTANT
6) QUADRATIC CONSTANT
7) CUTOFF ANGLE
8) OUTERCUTOFF ANGLE

THE FORMULAE TO CALCULATE ATTENUATION REMAINS THE SAME FOR A SPOTLIGHT
ATTENUATION=1.0 / (LIGHT.CONSTANT + LIGHT.LINEAR * DISTANCE + LIGHT.QUADRATIC * (DISTANCE * DISTANCE));

THE FORMULAR TO CALCULATE INTENSITY OF A SPOTLIGHT IS AS FOLLOWS
LIGHT DIRECTION= THE SPOTLIGHT DIRECTION THAT THE SPOT LIGHT IS POINTING AT
OBJECT DIRECTION= THE DIRECTION FROM THE OBJECT TO THE SPOTLIGHT
THETA= THE DOT PRODUCT BETWEEN LIGHT DIRECTION AND THE OBJECT DIRECTION
EPSILON= CUTOFF ANGLE - OUTERCUTOFFANGLE
INTENSITY= (THETA - OUTERCUTOFFANGLE) / (CUTOFF ANGLE - OUTERCUTOFFANGLE)
           THE VALUE OF INTENSITY IS CLAMPED BETWEEN 0.0 AND 1.0 SO IT DOES NOT GO NEGATIVE

THE ATTENUATION AND INTENSITY CALCULATED ABOVE IS THEN USED IN THE FINAL COLOR CALCULATIONS:
FINAL COLOR=((INTENSITY * ATTENUATION * AMBIENT COLOR) + (INTENSITY * ATTENUATION * DIFFUSE COLOR) + (INTENSITY * ATTENUATION * SPECULAR COLOR)) * COLOR OF THE OBJECT

//******************************
//    MULTPIPLE LIGHT SOURCES
//******************************
FOR MULTPLE LIGHT SOURCES THE "FINAL COLOR" VALUE FROM ALL OF THEM IS ADDED TOGETHER TO YIELD THE FINAL COLOR OF THE OBJECT
*************************************************/
void GameLight::GetDistanceValues(int Distance,float *Lin,float* Quad)
{
float Linear;
float Quadratic;

if (Distance >= 1 && Distance <= 7)
{
Linear = 0.7;
Quadratic = 1.8;
}
else if (Distance >= 8 && Distance <= 13)
{
Linear = 0.35;
Quadratic = 0.44;
}
else if (Distance >= 14 && Distance <= 20)
{
Linear = 0.22;
Quadratic = 0.20;
}
else if (Distance >= 21 && Distance <= 32)
{
Linear=0.14;
Quadratic=0.07;
}
else if (Distance >= 33 && Distance <= 50)
{
Linear=0.09;
Quadratic=0.032;
}
else if (Distance >= 51 && Distance <= 65)
{
Linear=0.07;
Quadratic=0.017;
}
else if (Distance >= 66 && Distance <= 100)
{
Linear=0.045;
Quadratic=0.0075;
}
else if (Distance >= 101 && Distance <= 160)
{
Linear=0.27;
Quadratic=0.0028;
}
else if (Distance >= 161 && Distance <= 200)
{
Linear=0.22;
Quadratic=0.0019;
}
else if (Distance >= 201 && Distance <= 325)
{
Linear=0.14;
Quadratic=0.0007;
}
else if (Distance >= 326 && Distance <= 600)
{
Linear=0.007;
Quadratic=0.0002;
}
else if (Distance >= 601 && Distance <= 3250)
{
Linear=0.0014;
Quadratic=0.000007;
}
else
{
Linear=0.09;
Quadratic=0.032;
}

*Lin=Linear;
*Quad=Quadratic;
}


//*******************************************
// SUN LIGHT / DIRECTIONAL LIGHT FUNCTIONS
//*******************************************
void GameLight::SunLight::UpdateColor(GameMath::Vector3 Color)
{
float data[4]={Color.x,Color.y,Color.z,0.0f};
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 8), 4 *  sizeof(float), &data[0]);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::SunLight::UpdateDirection(GameMath::Vector3 Direction)
{
float data[4]={Direction.x,Direction.y,Direction.z,0.0f};
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 16), 4 *  sizeof(float), &data[0]);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}
//*******************************************
// POINT LIGHT FUNCTIONS
//*******************************************
void GameLight::PointLight::SetupDistance(int Distance)
{
GetDistanceValues(Distance,&this->Linear,&this->Quadratic);
}

void GameLight::PointLight::UpdateColorXYZ(float x,float y,float z)
{
float data[4]={x,y,z,0.0f};
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 8), 4 *  sizeof(float), &data[0]);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::PointLight::UpdateColor(GameMath::Vector3 Color)
{
float data[4]={Color.x,Color.y,Color.z,0.0f};
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 8), 4 *  sizeof(float), &data[0]);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::PointLight::UpdatePosition(GameMath::Vector3 Position)
{
float data[4]={Position.x,Position.y,Position.z,1.0f};
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 12), 4 *  sizeof(float), &data[0]);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::PointLight::UpdateDistance(int Distance)
{
float Linear;
float Quadratic;
GetDistanceValues(Distance,&Linear,&Quadratic);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,7,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 2), 1 *  sizeof(float), &Linear);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 3), 1 *  sizeof(float), &Quadratic);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}
//*******************************************
// SPOT LIGHT FUNCTIONS
//*******************************************
void GameLight::SpotLight::SetupDistance(int Distance)
{
GetDistanceValues(Distance,&this->Linear,&this->Quadratic);
}

void GameLight::SpotLight::UpdateDirection(GameMath::Vector3 Direction)
{
float data[4]={Direction.x,Direction.y,Direction.z,0.0f};
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 16), 4 *  sizeof(float), &data[0]);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::SpotLight::UpdateColor(GameMath::Vector3 Color)
{
float data[4]={Color.x,Color.y,Color.z,0.0f};
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 8), 4 *  sizeof(float), &data[0]);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::SpotLight::UpdatePosition(GameMath::Vector3 Position)
{
float data[4]={Position.x,Position.y,Position.z,1.0f};
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 12), 4 *  sizeof(float), &data[0]);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::SpotLight::UpdateDistance(int Distance)
{
float Linear;
float Quadratic;
GetDistanceValues(Distance,&Linear,&Quadratic);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 2), 1 *  sizeof(float), &Linear);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 3), 1 *  sizeof(float), &Quadratic);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::SpotLight::UpdateCutOffAngle(float DegreeAngle)
{
float data=cos(GameMath::Transform::GetRadian(DegreeAngle));
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 4), 1 *  sizeof(float), &data);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}

void GameLight::SpotLight::UpdateOuterCutOffAngle(float DegreeAngle)
{
float data=cos(GameMath::Transform::GetRadian(DegreeAngle));
glBindBuffer(GL_SHADER_STORAGE_BUFFER, LightData_SSBO);
glBindBufferBase(GL_SHADER_STORAGE_BUFFER,LightData_Binding,LightData_SSBO);
glBufferSubData(GL_SHADER_STORAGE_BUFFER,DataIndex + (sizeof(float) * 5), 1 *  sizeof(float), &data);
glBindBuffer(GL_SHADER_STORAGE_BUFFER, 0);
}





